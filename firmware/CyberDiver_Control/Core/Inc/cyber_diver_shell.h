/*
 * cyber_diver_shell.h
 *
 *  Created on: Oct 28, 2024
 *      Author: johnt
 */

#ifndef INC_CYBER_DIVER_SHELL_H_
#define INC_CYBER_DIVER_SHELL_H_

#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

/*
 * control the CyberDiver through a text-based shell
 */

/*
 * The shell contains FIFO text buffers for inputs and outputs.
 * When using this class, write to the input buffer with whatever interface hardware
 * we are using (UBS/UART/I2C/...). The shell contains arrays of generic input and output
 * handlers. The input handlers represent commands that we want to send to the device
 * to make it do something with the hardware. The output handlers represent messages that the
 * device is sending to the host, or streams of data generated by sensors. The design is decoupled
 * through the command pattern: the individual hardware subsystems and the shell do not need to know
 * about each other. A specific command can be implemented which knows about the shell and can access
 * the subsystem member functions.
 *
 * The shell expects commands to be terminated with a delimiter, and it will terminate its outgoing
 * messages with that same delimiter. It expects the input to consist of tokens separated by one of
 * the specified separator characters. The shell implements token-ization functions that can be used
 * by the concrete input handler implementations to easily parse the input string. Likewise the concrete
 * output handlers can choose to format the output string however they want.
 *
 * Inputs can be added to the input buffer at any point, and output handlers can generate data at any point
 * but they should buffer it locally since there is some delay between shell updates. When we call the shell
 * update function, it will check whether it has received any full messages (ending in delimiters) in the input buffer.
 * It will call any input handlers it has for the input messages. Then it will check through all of the output
 * handlers to see whether they have data ready. The update function will return a status flag which tells whether
 * it parsed inputs or outputs - this flag can be used to know when to start the hardware data transfer.
 */

#define CD_SHELL_IO_BUF_LEN 32768

#define CD_SHELL_MAX_OUTPUT_PACKET_LEN 4096  /*
												this is the assumed longest output packet - we always want to send a complete packet with delimiter if possible.
												(this is motivated by CDC_Transmit_HS sometimes seeming to send data out of order if you call the function repeatedly)
												If we exceed the assumed packet length, it should send in two separate outputs without breaking everything.
												*/

#define CD_SHELL_MAX_TOKEN_LEN 64
#define CD_SHELL_MAX_NUM_HANDLERS 64


#define CD_SHELL_DELIMITER "\n"
#define CD_SHELL_INPUT_SEPARATORS " ,"
#define CD_SHELL_OUTPUT_SEPARATOR " "
#define CD_SHELL_FLOAT_FORMAT "%.8f"


struct CyberDiverShell_s;

typedef struct
{
	char name[CD_SHELL_MAX_TOKEN_LEN];  /* first token of the input command string should be the name of which command to invoke */
	uint32_t (*execute)(void*, struct CyberDiverShell_s*);  /* return true if we parse and execute successfully */
	void* obj;  /* object that the command acts on */
} CyberDiverShell_InputHandler;


typedef struct
{
	uint32_t (*execute)(void*, struct CyberDiverShell_s*);  /* return true when this output handler is ready to send data */
	void* obj;  /* object that the handler gets data from */
} CyberDiverShell_OutputHandler;


typedef enum
{
	CD_SHELL_NO_INPUT,  /* we didn't get a complete message on this update */
	CD_SHELL_INPUT_PROCESSED,  /* successfully handled the input status */
	CD_SHELL_INPUT_ERROR_NO_HANDLER,  /* we received a message that we don't have a handler for */
	CD_SHELL_INPUT_ERROR_EXECUTING  /* we have a handler but it could not execute successfully */
} CyberDiverShell_InputHandlerStatus;


typedef enum
{
	CD_SHELL_NO_OUTPUT,  /* none of the output handlers are ready to send data */
	CD_SHELL_OUTPUT_PROCESSED  /* we successfully executed an output handler */
} CyberDiverShell_OutputHandlerStatus;


typedef enum
{
	CD_SHELL_INPUT_BUFFER_OK,
	CD_SHELL_INPUT_BUFFER_OVERFLOW
} CyberDiverShell_InputBufferStatus;


typedef enum
{
	CD_SHELL_OUTPUT_BUFFER_OK,
	CD_SHELL_OUTPUT_BUFFER_OVERFLOW
} CyberDiverShell_OutputBufferStatus;


typedef struct
{
	CyberDiverShell_InputHandlerStatus ihandl_status;
	CyberDiverShell_OutputHandlerStatus ohandl_status;
	CyberDiverShell_InputBufferStatus ibuf_status;
	CyberDiverShell_OutputBufferStatus obuf_status;
} CyberDiverShell_Status;


struct CyberDiverShell_s
{
	char input[CD_SHELL_IO_BUF_LEN];
	uint32_t input_head, input_tail;
	uint32_t input_count;  /* keeps track of how full the input buffer is */
	uint32_t input_delimiter_count;  /* keeps track of how many complete messages we have */

	char output[CD_SHELL_IO_BUF_LEN];
	uint32_t output_head, output_tail;
	uint32_t output_end;  /* 0 if no output packet has wrapped, else it is the location of the end of the packet */
	uint32_t output_count;  /* keeps track of how full the output buffer is */

	CyberDiverShell_InputHandler input_handlers[CD_SHELL_MAX_NUM_HANDLERS];
	uint32_t ih_count;
	CyberDiverShell_OutputHandler output_handlers[CD_SHELL_MAX_NUM_HANDLERS];
	uint32_t oh_count;
};

typedef struct CyberDiverShell_s CyberDiverShell;

void CyberDiverShell_Init(CyberDiverShell* shell);
CyberDiverShell_Status CyberDiverShell_Update(CyberDiverShell* shell);

void CyberDiverShell_ClearInputHandlers(CyberDiverShell* shell);
void CyberDiverShell_ClearOutputHandlers(CyberDiverShell* shell);
void CyberDiverShell_RegisterInputHandler(CyberDiverShell* shell, CyberDiverShell_InputHandler handler);
void CyberDiverShell_RegisterOutputHandler(CyberDiverShell* shell, CyberDiverShell_OutputHandler handler);

void CyberDiverShell_PutInput(CyberDiverShell* shell, char* input, uint32_t input_max_len);  /* add to the input buffer */
uint32_t CyberDiverShell_GetOutput(CyberDiverShell* shell, char** output, uint32_t* len);  /* returns true if there is stuff in the output buffer we haven't yet sent */
void CyberDiverShell_UpdateOutputBuffer(CyberDiverShell* shell, uint32_t len);  /* once we have successfully sent the output data, update the buffer pointers */

uint32_t CyberDiverShell_GetNextString(CyberDiverShell* shell, char* next, uint32_t max_len);
uint32_t CyberDiverShell_GetNextInt(CyberDiverShell* shell, int32_t* next);
uint32_t CyberDiverShell_GetNextFloat(CyberDiverShell* shell, float* next);

uint32_t CyberDiverShell_TurnToInt(char* str, int32_t* next);  /* if the type of the next token is not known, get it as a string and then try to convert it to numeric using these functions */
uint32_t CyberDiverShell_TurnToFloat(char* str, float* next);

void CyberDiverShell_PutOutputString(CyberDiverShell* shell, char* str);  /* add things to the output */
void CyberDiverShell_PutOutputInt(CyberDiverShell* shell, int32_t val);
void CyberDiverShell_PutOutputUint(CyberDiverShell* shell, uint32_t val);
void CyberDiverShell_PutOutputFloat(CyberDiverShell* shell, float val);

void CyberDiverShell_PutOutputSeparator(CyberDiverShell* shell);
void CyberDiverShell_PutOutputDelimiter(CyberDiverShell* shell);


#endif /* INC_CYBER_DIVER_SHELL_H_ */
